---
description:
globs:
alwaysApply: false
---
# WebPrinter 트러블슈팅 가이드

## 설치 및 실행 문제

### "WebPrinter 설치가 필요합니다" 메시지가 계속 표시
**증상**: 앱을 설치했는데도 웹페이지에서 설치하라는 메시지가 나타남

**진단 방법**:
```bash
# 1. 프로세스 확인
ps aux | grep -i webprinter

# 2. 포트 확인 (18731)
lsof -i :18731
netstat -an | grep 18731

# 3. 프로토콜 핸들러 확인
open webprinter://test
```

**가능한 원인**:
1. **HTTP 서버 미실행**: [main.js](mdc:main.js)의 `startHttpServer()` 호출 확인
2. **포트 충돌**: 18731 포트가 다른 프로세스에서 사용 중
3. **프로토콜 미등록**: `webprinter://` 프로토콜 핸들러 등록 실패
4. **CORS 문제**: 웹페이지와 로컬 서버 간 통신 차단

**해결 방법**:
```javascript
// [main.js](mdc:main.js)에서 포트 충돌 시 대안 포트 사용
const findAvailablePort = async (startPort) => {
    // 18731부터 18740까지 시도
    for (let port = startPort; port < startPort + 10; port++) {
        try {
            await new Promise((resolve, reject) => {
                const server = require('net').createServer();
                server.listen(port, () => {
                    server.close(resolve);
                }).on('error', reject);
            });
            return port;
        } catch (error) {
            continue;
        }
    }
    throw new Error('No available port found');
};
```

### macOS 코드 서명 문제
**증상**: "개발자를 확인할 수 없음" 또는 실행 거부

**해결 방법**:
1. **시스템 환경설정 → 보안 및 개인정보보호 → 일반**에서 "확인된 개발자의 앱 허용" 선택
2. 터미널에서 격리 속성 제거:
   ```bash
   xattr -cr /Applications/WebPrinter.app
   ```
3. Gatekeeper 우회 (임시):
   ```bash
   sudo spctl --master-disable
   ```

### Windows Defender 오탐지
**증상**: Windows Defender가 WebPrinter를 악성코드로 진단

**해결 방법**:
1. **Windows 보안 → 바이러스 및 위협 방지 → 제외 항목 관리**
2. WebPrinter 설치 폴더를 제외 목록에 추가
3. Microsoft에 오탐 신고: https://www.microsoft.com/security/portal/submission/submit.aspx

## 빌드 문제

### "Cannot find module 'express'" 에러
**증상**: 빌드된 앱이 실행되지 않고 모듈 누락 에러

**원인**: [package.json](mdc:package.json)의 `build.files` 설정 문제

**해결 방법**:
```json
// package.json - 올바른 files 설정
"build": {
    "files": [
        "main.js",
        "preload.js", 
        "print-preview.html",
        "print-preview.js",
        "web-example.html",
        "package.json"
    ]
}
```

### GitHub Actions 빌드 실패
**증상**: CI/CD 파이프라인에서 빌드 실패

**공통 문제들**:
1. **Yarn vs NPM 충돌**:
```yaml
# [.github/workflows/build.yml](mdc:.github/workflows/build.yml)
env:
  npm_config_package_manager: yarn
  ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES: true
```

2. **버전 동기화 실패** (Windows):
```yaml
# OS별 버전 추출
- name: Set version from tag (Windows)
  if: runner.os == 'Windows'
  shell: pwsh
  run: |
    $TAG_VERSION = $env:GITHUB_REF -replace 'refs/tags/v', ''
    npm version $TAG_VERSION --no-git-tag-version
```

3. **권한 부족** (GitHub Releases):
```yaml
permissions:
  contents: write
  discussions: write
```

## 네트워킹 문제

### 웹페이지에서 로컬 서버 접근 실패
**증상**: `findWebPrinterServer()` 함수가 항상 실패

**진단**:
```javascript
// [web-example.html](mdc:web-example.html)에 디버깅 추가
async function debugConnection() {
    const ports = [18731, 18732, 18733];
    for (const port of ports) {
        try {
            const response = await fetch(`http://localhost:${port}/status`);
            console.log(`Port ${port}: OK`, await response.json());
        } catch (error) {
            console.log(`Port ${port}: Failed`, error.message);
        }
    }
}
```

**해결 방법**:
1. **방화벽 확인**: macOS/Windows 방화벽에서 로컬 접근 허용
2. **CORS 설정**: [main.js](mdc:main.js)에서 `origin: '*'` 확인
3. **브라우저 보안**: Chrome의 로컬 파일 제한 우회

## 인쇄 문제

### 용지 크기 설정 무시
**증상**: 커스텀 용지 크기(244mm x 88mm)가 적용되지 않음

**해결 방법**:
```javascript
// [main.js](mdc:main.js) - 올바른 용지 크기 설정
const paperSize = {
    width_microns: Math.round(options.paperSize.width * 1000),
    height_microns: Math.round(options.paperSize.height * 1000)
};

hiddenWindow.webContents.print({
    silent: false,
    printBackground: true,
    pageSize: paperSize
});
```

### 프린터 선택 안됨
**증상**: 사용자가 선택한 프린터가 무시됨

**해결 방법**:
```javascript
// 프린터 목록 가져오기 및 선택 적용
const printers = await hiddenWindow.webContents.getPrintersAsync();
const selectedPrinter = printers.find(p => p.name === printerName);

if (selectedPrinter) {
    printOptions.deviceName = selectedPrinter.name;
}
```

## 디버깅 도구

### 개발 중 유용한 명령어
```bash
# Electron 앱 로그 확인 (macOS)
tail -f ~/Library/Logs/WebPrinter/main.log

# 프로토콜 핸들러 테스트
open webprinter://print?session=test123

# HTTP 서버 테스트
curl http://localhost:18731/status

# 빌드 테스트 (로컬)
npm run build-mac
npm run build-win
```

### 프로덕션 디버깅
```javascript
// [main.js](mdc:main.js)에 디버깅 모드 추가
const isDev = process.env.NODE_ENV === 'development';

if (isDev) {
    printWindow.webContents.openDevTools();
    console.log('Debug mode enabled');
}
```

## IPC 통신 문제

### electronAPI 객체 없음
**증상**: `❌ IPC 통신 실패: electronAPI 객체 없음` Toast 메시지

**진단 과정**:
1. **개발자 도구에서 확인**:
   ```javascript
   console.log('electronAPI 존재:', typeof window.electronAPI);
   console.log('electronAPI 내용:', window.electronAPI);
   ```

2. **preload.js 로딩 확인**:
   ```bash
   # 앱 실행 로그에서 확인
   ✅ preload.js 로드 완료
   ✅ contextBridge 설정 완료
   ```

**가능한 원인**:
1. **preload.js 파일 경로 오류**
2. **contextIsolation 설정 문제**
3. **Electron 버전 호환성 문제**

**해결 방법**:
```javascript
// [main.js](mdc:main.js)에서 webPreferences 확인
webPreferences: {
    nodeIntegration: false,
    contextIsolation: true,           // 반드시 true
    enableRemoteModule: false,
    preload: path.join(__dirname, 'preload.js')  // 절대 경로 사용
}
```

### IPC 메시지 전송 실패
**증상**: `⚠️ IPC 메시지 전송 조건 불충족` 콘솔 로그

**진단**:
```javascript
// [main.js](mdc:main.js)에서 상태 확인
console.log(`printWindow 존재: ${!!printWindow}`);
console.log(`printWindow destroyed: ${printWindow?.isDestroyed()}`);
console.log(`currentSession: ${currentSession}`);
console.log(`요청 sessionId: ${sessionId}`);
```

**해결 방법**:
```javascript
// 안전한 IPC 전송 패턴
const safeIpcSend = (channel, data) => {
    if (printWindow && !printWindow.isDestroyed()) {
        if (printWindow.webContents.isLoading()) {
            printWindow.webContents.once('did-finish-load', () => {
                setTimeout(() => {
                    if (printWindow && !printWindow.isDestroyed()) {
                        printWindow.webContents.send(channel, data);
                    }
                }, 500);
            });
        } else {
            printWindow.webContents.send(channel, data);
        }
    }
};
```

### IPC API 호출 타임아웃
**증상**: `❌ getServerInfo API 실패: Timeout` 에러

**원인**:
- 메인 프로세스 블로킹
- 과도한 IPC 호출
- 메모리 부족

**해결 방법**:
```javascript
// [print-preview.js](mdc:print-preview.js)에서 타임아웃 설정
const callIpcWithTimeout = async (method, ...args) => {
    const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('IPC Timeout')), 5000)
    );
    
    try {
        return await Promise.race([
            window.electronAPI[method](...args),
            timeoutPromise
        ]);
    } catch (error) {
        console.error(`IPC ${method} 호출 실패:`, error);
        throw error;
    }
};
```

### 실시간 IPC 모니터링 활용
**Toast 메시지로 상태 확인**:
- ✅ `IPC 통신 정상 작동 (100%)`: 모든 기능 정상
- ⚠️ `IPC 통신 부분 작동 (70%)`: 일부 기능 제한
- ❌ `IPC 통신 심각한 문제 (33%)`: 시스템 재시작 필요

**자동 복구 시스템**:
```javascript
// 3회 연속 실패 시 자동 복구 시도
if (consecutiveFailures >= 3) {
    showToast('🔧 IPC 통신 복구 시도 중...', 'warning', 3000);
    setTimeout(() => {
        window.location.reload();
    }, 3000);
}
```

## 성능 최적화

### 메모리 사용량 증가
**진단**:
```javascript
// [main.js](mdc:main.js)에서 메모리 모니터링
setInterval(() => {
    const usage = process.memoryUsage();
    console.log('메모리 사용량:', {
        rss: Math.round(usage.rss / 1024 / 1024) + 'MB',
        heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + 'MB'
    });
}, 30000);
```

**최적화 방법**:
```javascript
// 윈도우 정리 자동화
const cleanupWindow = () => {
    if (tempPrintWindow && !tempPrintWindow.isDestroyed()) {
        tempPrintWindow.close();
        tempPrintWindow = null;
    }
};

// 세션 데이터 정리
const cleanOldSessions = () => {
    const now = Date.now();
    const maxAge = 24 * 60 * 60 * 1000; // 24시간
    
    Object.keys(receivedUrls).forEach(sessionId => {
        const sessionData = receivedUrls[sessionId];
        if (sessionData.timestamp && (now - sessionData.timestamp) > maxAge) {
            delete receivedUrls[sessionId];
        }
    });
};
```

## 로그 수집 및 분석

### 디버그 모드 활성화
```bash
# 환경 변수 설정으로 상세 로그 활성화
DEBUG=* npm start
ELECTRON_ENABLE_LOGGING=1 npm start
```

### 로그 파일 위치
- **Windows**: `%APPDATA%\WebPrinter\logs\`
- **macOS**: `~/Library/Logs/WebPrinter/`
- **Linux**: `~/.config/WebPrinter/logs/`

### 중요한 로그 패턴
```bash
# 성공적인 초기화
✅ HTTP 서버 시작됨: http://localhost:18731
✅ 프로토콜 핸들러 등록: 성공
✅ 시작 프로그램 등록 완료

# IPC 통신 상태
✅ IPC 통신 정상 작동 (100%)
📡 IPC 통신 모니터링 시작됨

# 인쇄 과정
🖨️ Electron 인쇄 시작
✅ URL 로딩 완료
✅ 페이지 렌더링 완료
✅ 프린트 성공
```
