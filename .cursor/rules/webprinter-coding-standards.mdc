---
alwaysApply: true
---
# WebPrinter 코딩 표준

## 1. 네이밍 규칙

### 변수명
```javascript
// ✅ 좋은 예
let currentSession = null;
let receivedUrls = {};
let isPrinting = false;
let serverPort = 18731;

// ❌ 나쁜 예
let curr_sess = null;
let urls = {};
let printing = false;
```

### 함수명
```javascript
// ✅ 동사로 시작하는 명확한 이름
async function createPrintWindow() {}
function handleUrlsReceived() {}
function updateLoadingStep() {}
async function generatePDF() {}

// ❌ 명사형이나 불명확한 이름
function window() {}
function urls() {}
function loading() {}
```

### 상수
```javascript
// ✅ UPPER_SNAKE_CASE 사용
const MAX_RETRIES = 3;
const DEFAULT_PORT = 18731;
const SESSION_TIMEOUT = 24 * 60 * 60 * 1000;

// ❌ 다른 형식
const maxRetries = 3;
const default_port = 18731;
```

### 파일명
- 모듈: kebab-case (예: `print-preview.js`, `ui-manager.js`)
- HTML: kebab-case (예: `print-preview.html`)
- CSS: kebab-case (예: `print-preview.css`)

## 2. 에러 처리 패턴

### 비동기 함수
```javascript
// ✅ 표준 에러 처리 패턴
async function printViaPDF(url, paperSize) {
  try {
    // 먼저 파라미터 검증
    if (!url) {
      throw new Error('인쇄할 URL이 없습니다');
    }
    
    // 메인 로직
    const pdfBuffer = await generatePDF(url, paperSize);
    return { success: true, data: pdfBuffer };
    
  } catch (error) {
    // 사용자 친화적 메시지 변환
    let errorMessage = error.message;
    if (error.message.includes('ERR_NAME_NOT_RESOLVED')) {
      errorMessage = 'URL에 접근할 수 없습니다. 인터넷 연결을 확인해주세요.';
    }
    
    return { success: false, error: errorMessage };
  }
}
```

### IPC 통신 에러 처리
```javascript
// ✅ IPC 핸들러의 표준 패턴
ipcMain.handle('print-url', async (event, params) => {
  console.log('print-url IPC 호출됨:', params);
  
  try {
    // 파라미터 검증
    if (!params.url) {
      throw new Error('인쇄할 URL이 없습니다');
    }
    
    // 처리 로직
    const result = await printViaPDF(params);
    return result;
    
  } catch (error) {
    console.error('인쇄 오류:', error);
    return { 
      success: false, 
      error: error.message || '알 수 없는 오류가 발생했습니다'
    };
  }
});
```

## 3. 함수 구조 원칙

### 단일 책임 원칙
```javascript
// ✅ 좋은 예 - 각 함수가 하나의 일만 수행
async function generatePDF(url, paperSize) {
  // PDF 생성만 담당
}

async function savePermanentPDF(pdfBuffer) {
  // PDF 저장만 담당
}

async function openPDFPreview(pdfPath) {
  // PDF 미리보기만 담당
}

// ❌ 나쁜 예 - 여러 책임을 가진 함수
async function handlePDF(url, paperSize) {
  // PDF 생성, 저장, 미리보기를 모두 처리
}
```

### 매개변수 제한
```javascript
// ✅ 좋은 예 - 3개 이하의 매개변수
function createWindow(sessionId, width, height) {}

// ✅ 더 좋은 예 - 옵션 객체 사용
function createWindow(options) {
  const { sessionId, width, height, show } = options;
}

// ❌ 나쁜 예 - 너무 많은 매개변수
function createWindow(sessionId, width, height, x, y, resizable, frame) {}
```

## 4. 모듈 패턴

### exports 패턴
```javascript
// ✅ 명시적 exports (modules/server.js 패턴)
module.exports = {
  startHttpServer,
  stopHttpServer,
  loadSessionData,
  cleanOldSessions,
  getServerPort: () => serverPort,
  getSessionData: (sessionId) => receivedUrls[sessionId]
};

// ✅ 구조분해를 통한 깔끔한 imports
const { createPrintWindow, notifyWindow } = require('./window');
```

## 5. 비동기 처리 원칙

### async/await 우선 사용
```javascript
// ✅ 좋은 예
async function loadPrinters() {
  try {
    const result = await IPCHandler.getPrinters();
    if (result.success) {
      UIManager.updatePrinterList(result.printers);
    }
  } catch (error) {
    console.error('프린터 로드 실패:', error);
  }
}

// ❌ 콜백 지옥
getPrinters((error, printers) => {
  if (error) {
    handleError(error);
  } else {
    updateUI(printers, () => {
      // 더 깊은 중첩...
    });
  }
});
```

### Promise 적절히 활용
```javascript
// ✅ 병렬 처리가 필요한 경우
const [serverInfo, printers] = await Promise.all([
  getServerInfo(),
  getPrinters()
]);

// ✅ 타임아웃 처리
await Promise.race([
  loadURL(url),
  new Promise((_, reject) => 
    setTimeout(() => reject(new Error('시간 초과')), 5000)
  )
]);
```

## 6. 타입 체크 및 검증

### 파라미터 검증
```javascript
// ✅ 함수 시작 시 검증
function setPaperSize(width, height) {
  // null/undefined 체크
  if (width == null || height == null) {
    throw new Error('용지 크기는 필수입니다');
  }
  
  // 타입 변환 및 검증
  const paperWidth = parseFloat(width);
  const paperHeight = parseFloat(height);
  
  if (isNaN(paperWidth) || isNaN(paperHeight)) {
    throw new Error('잘못된 용지 크기입니다');
  }
  
  if (paperWidth <= 0 || paperHeight <= 0) {
    throw new Error('용지 크기는 0보다 커야 합니다');
  }
  
  // 메인 로직
}
```

## 7. 주석 작성 원칙

```javascript
// ✅ 좋은 예 - "왜"를 설명
// macOS에서 렌더링 문제를 방지하기 위해 비활성화
app.commandLine.appendSwitch('disable-features', 'CalculateNativeWinOcclusion');

// 5초 후 임시 파일 삭제 (프린터 스풀링 완료 대기)
setTimeout(async () => {
  await fs.unlink(tempPath);
}, 5000);

// ❌ 나쁜 예 - "무엇"을 설명 (코드로 충분)
// 서버를 시작합니다
startHttpServer();

// 포트를 18731로 설정합니다
const port = 18731;
```

## 8. UI 업데이트 패턴

```javascript
// ✅ 중앙집중식 UI 관리
UIManager.showStatus('인쇄 중...', 'info');
UIManager.updatePrintButton(true);
UIManager.showToast('✅ 인쇄 완료', 'success');

// ❌ 직접 DOM 조작
document.getElementById('status').textContent = '인쇄 중...';
document.getElementById('print-btn').disabled = false;
```